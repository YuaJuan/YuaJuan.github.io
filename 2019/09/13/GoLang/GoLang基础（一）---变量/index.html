<!DOCTYPE html>





<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="GO遵循“少既是多”原理，使代码风格变得非常简洁。Go语言很可能是第一个将代码风格强制统一的语言。Go语言支持类、类成员方法、类的组合，但反对继承，反对虚函数（virtual function）和虚函数重载。确切地说，Go也提供了继承，只不过是采用了组合的文法来提供。Go语言也放弃了构造函数（constructor）和析构函数（destructor），在放弃了大量的OOP特性后，Go语言送上了一份">
<meta name="keywords" content="go">
<meta property="og:type" content="article">
<meta property="og:title" content="GOLang基础（一）---变量.md">
<meta property="og:url" content="https://yuajuan.github.io/2019/09/13/GoLang/GoLang基础（一）---变量/index.html">
<meta property="og:site_name" content="发现问题并解决问题">
<meta property="og:description" content="GO遵循“少既是多”原理，使代码风格变得非常简洁。Go语言很可能是第一个将代码风格强制统一的语言。Go语言支持类、类成员方法、类的组合，但反对继承，反对虚函数（virtual function）和虚函数重载。确切地说，Go也提供了继承，只不过是采用了组合的文法来提供。Go语言也放弃了构造函数（constructor）和析构函数（destructor），在放弃了大量的OOP特性后，Go语言送上了一份">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://img-blog.csdn.net/2018092710031168">
<meta property="og:image" content="https://img-blog.csdn.net/20180927100812323">
<meta property="og:updated_time" content="2019-03-03T14:01:16.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GOLang基础（一）---变量.md">
<meta name="twitter:description" content="GO遵循“少既是多”原理，使代码风格变得非常简洁。Go语言很可能是第一个将代码风格强制统一的语言。Go语言支持类、类成员方法、类的组合，但反对继承，反对虚函数（virtual function）和虚函数重载。确切地说，Go也提供了继承，只不过是采用了组合的文法来提供。Go语言也放弃了构造函数（constructor）和析构函数（destructor），在放弃了大量的OOP特性后，Go语言送上了一份">
<meta name="twitter:image" content="https://img-blog.csdn.net/2018092710031168">
  <link rel="canonical" href="https://yuajuan.github.io/2019/09/13/GoLang/GoLang基础（一）---变量/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>GOLang基础（一）---变量.md | 发现问题并解决问题</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">发现问题并解决问题</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">心之所向，不慌不忙</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-commonweal">
      
    

    <a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>Commonweal 404</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://yuajuan.github.io/2019/09/13/GoLang/GoLang基础（一）---变量/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="阿娟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="发现问题并解决问题">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">GOLang基础（一）---变量.md

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-13 12:49:44" itemprop="dateCreated datePublished" datetime="2019-09-13T12:49:44+08:00">2019-09-13</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-03-03 22:01:16" itemprop="dateModified" datetime="2019-03-03T22:01:16+08:00">2019-03-03</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>GO遵循“少既是多”原理，使代码风格变得非常简洁。<br>Go语言很可能是第一个将代码风格强制统一的语言。Go语言支持类、类成员方法、类的组合，但反对继承，反对虚函数（virtual function）<br>和虚函数重载。确切地说，Go也提供了继承，只不过是采用了组合的文法来提供。Go语言也放弃了构造函数（constructor）和析构函数（destructor），<br>在放弃了大量的OOP特性后，Go语言送上了一份非常棒的礼物：接口（interface）。<br>Go语言中的接口与其他语言最大的一点区别是它的非侵入性。<br>Python是一种解释型语言，既没有编译的过程。并且具有很强的可读性。面向对象，可嵌入: 你可以将Python嵌入到C/C++程序，让你的程序的用户获得”脚本化”的能力</p>
<h1 id="1变量"><a href="#1变量" class="headerlink" title="1变量"></a>1变量</h1><h2 id="1-1变量声明"><a href="#1-1变量声明" class="headerlink" title="1.1变量声明"></a>1.1变量声明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var v1 int</span><br><span class="line">var v2 string</span><br><span class="line">var v3 [10]int // 数组</span><br><span class="line">var v4 []int // 数组切片</span><br><span class="line">var v5 struct &#123; </span><br><span class="line"> f int</span><br><span class="line">&#125; </span><br><span class="line">var v6 *int // 指针</span><br><span class="line">var v7 map[string]int // map，key为string类型，value为int类型</span><br><span class="line">var v8 func(a int) int</span><br></pre></td></tr></table></figure>

<p>同时声明多个变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ( </span><br><span class="line"> v1 int</span><br><span class="line"> v2 string</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="1-2变量初始化"><a href="#1-2变量初始化" class="headerlink" title="1.2变量初始化"></a>1.2变量初始化</h2><p>对变量初始化时，var可用可不用</p>
<pre><code>var v1 int = 10 // 正确的使用方式1 
var v2 = 10 // 正确的使用方式2，编译器可以自动推导出v2的类型
v3 := 10 // 正确的使用方式3，编译器可以自动推导出v3的类型</code></pre><p>注意：=和:=的区别 ，:=用于初始化变量</p>
<h2 id="1-3变量赋值"><a href="#1-3变量赋值" class="headerlink" title="1.3变量赋值"></a>1.3变量赋值</h2><p>变量赋值和变量初始化不一样</p>
<pre><code>var v10 int
v10 = 123 </code></pre><p> go语言支持多重赋值</p>
<pre><code>i, j = j, i </code></pre><h2 id="1-4匿名变量"><a href="#1-4匿名变量" class="headerlink" title="1.4匿名变量"></a>1.4匿名变量</h2><pre><code>func GetName() (firstName, lastName, nickName string) { 
 return &quot;May&quot;, &quot;Chan&quot;, &quot;Chibi Maruko&quot; 
} 
//若只想获得nickName，则函数调用语句可以用如下方式编写：
_, _, nickName := GetName() </code></pre><h2 id="1-5常量"><a href="#1-5常量" class="headerlink" title="1.5常量"></a>1.5常量</h2><pre><code>const Pi float64 = 3.14159265358979323846 
const zero = 0.0 // 无类型浮点常量
const (
 size int64 = 1024 
 eof = -1 // 无类型整型常量
) 
const u, v float32 = 0, 3 // u = 0.0, v = 3.0，常量的多重赋值
const a, b, c = 3, 4, &quot;foo&quot; 
// a = 3, b = 4, c = &quot;foo&quot;, 无类型整型和字符串常量</code></pre><p>常量定义的右值也可以是一个在编译期运算的常量表达式，比如<br>const mask = 1 &lt;&lt; 3<br>由于常量的赋值是一个编译期行为，所以<strong>右值不能出现任何需要运行期才能得出结果的表达<br>式</strong>，比如试图以如下方式定义常量就会导致编译错误：<br>const Home = os.GetEnv(“HOME”) </p>
<h1 id="1-3预定义常量"><a href="#1-3预定义常量" class="headerlink" title="1.3预定义常量"></a>1.3预定义常量</h1><p>Go语言中的预定义常量：true,false,iota</p>
<p>iota是一个可被编译器修改的常量，在每一个const关键字出现时被重置为0，然后在下一个const出现之前，每出现一次iota，其值增1。</p>
<pre><code>const ( // iota被重设为0
 c0 = iota // c0 == 0 
 c1 = iota // c1 == 1 
 c2 = iota // c2 == 2 
) 
const ( 
 a = 1 &lt;&lt; iota // a == 1 (iota在每个const开头被重设为0) 
 b = 1 &lt;&lt; iota // b == 2 
 c = 1 &lt;&lt; iota // c == 4 
) </code></pre><p>如果两个const的赋值语句的表达式是一样的，那么可以省略后一个赋值表达式。因此，上面的前两个const语句可简写为：</p>
<pre><code>const ( // iota被重设为0
 c0 = iota    // c0 == 0 
 c1              // c1 == 1 
 c2              // c2 == 2 
) 
const ( 
 a = 1 &lt;&lt;iota        // a == 1 (iota在每个const开头被重设为0) 
 b                 // b == 2 
 c                 // c == 4 
) </code></pre><h2 id="1-4枚举"><a href="#1-4枚举" class="headerlink" title="1.4枚举"></a>1.4枚举</h2><p>Go语言没有像其他编程语言一样的enum关键字</p>
<pre><code>const ( 
 Sunday = iota
 Monday 
 Tuesday 
 Wednesday 
 Thursday 
 Friday 
 Saturday 
 numberOfDays // 这个常量没有导出 
) </code></pre><p><strong><em>同Go语言的其他符号（symbol）一样，以大写字母开头的常量在包外可见。</em></strong><br>以上例子中numberOfDays为包内私有，其他符号则可被其他包访问。</p>
<h1 id="2类型"><a href="#2类型" class="headerlink" title="2类型"></a>2类型</h1><p>Go语言内置以下这些基础类型： </p>
<pre><code> 布尔类型：bool。
 整型：int8、byte、int16、int、uint、uintptr等。
 浮点类型：float32、float64。
 复数类型：complex64、complex128。
 字符串：string。
 字符类型：rune。
 错误类型：error。
此外，Go语言也支持以下这些复合类型：
 指针（pointer）
 数组（array）
 切片（slice）
 字典（map）
 通道（chan）
 结构体（struct）
 接口（interface）</code></pre><h2 id="2-1布尔类型"><a href="#2-1布尔类型" class="headerlink" title="2.1布尔类型"></a>2.1布尔类型</h2><pre><code>var v1 bool
v1 = true
v2 := (1 == 2) // v2也会被推导为bool类型</code></pre><p>布尔类型不能接受其他类型的赋值，不支持自动或强制的类型转换</p>
<pre><code>b = 1 // 编译错误
b = bool(1) // 编译错误
以下的用法才是正确的：
var b bool
b = (1!=0) // 编译正确 
fmt.Println(&quot;Result:&quot;, b) // 打印结果为Result: true </code></pre><h2 id="2-2整型"><a href="#2-2整型" class="headerlink" title="2.2整型"></a>2.2整型</h2><p><img src="https://img-blog.csdn.net/2018092710031168" alt="在这里插入图片描述"></p>
<p>int和int32是不同类型，编译器不是帮助做自动转换</p>
<pre><code>var value2 int32
value1 := 64 // value1将会被自动推导为int类型
value2 = value1 // 编译错误
编译错误类似于：
cannot use value1 (type int) as type int32 in assignment。
使用强制类型转换可以解决这个编译错误：
value2 = int32(value1) // 编译通过
//开发者在做强制类型转换时，需要注意数据长度被截短而发生的数据精
度损失（比如将浮点数强制转为整数）和值溢出（值超过转换的目标类型的值范围时）问题。

//两个不同类型的整型数不能直接比较，比如int8类型的数和int类型的数不能直接比较，但
各种类型的整型变量都可以直接与字面常量（literal）进行比较</code></pre><h2 id="2-3位运算"><a href="#2-3位运算" class="headerlink" title="2.3位运算"></a>2.3位运算</h2><p><img src="https://img-blog.csdn.net/20180927100812323" alt="在这里插入图片描述"></p>
<h2 id="2-4浮点类型"><a href="#2-4浮点类型" class="headerlink" title="2.4浮点类型"></a>2.4浮点类型</h2><p>float32和float64的关系与前面的整型一样<br>浮点数作比较</p>
<pre><code>import &quot;math&quot; 
// p为用户自定义的比较精度，比如0.00001 
func IsEqual(f1, f2, p float64) bool { 
 return math.Fdim(f1, f2) &lt; p 
} </code></pre><h2 id="2-5复数"><a href="#2-5复数" class="headerlink" title="2.5复数"></a>2.5复数</h2><h4 id="1-复数表示"><a href="#1-复数表示" class="headerlink" title="1. 复数表示"></a>1. 复数表示</h4><p>复数表示的示例如下：</p>
<pre><code>var value1 complex64 // 由2个float32构成的复数类型
value1 = 3.2 + 12i 
value2 := 3.2 + 12i // value2是complex128类型
value3 := complex(3.2, 12) // value3结果同 value2 </code></pre><h4 id="2-实部和虚部"><a href="#2-实部和虚部" class="headerlink" title="2.实部和虚部"></a>2.实部和虚部</h4><p>对于一个复数z = complex(x, y)，就可以通过Go语言内置函数real(z)获得该复数的实部，也就是x，通过imag(z)获得该复数的虚部，也就是y。</p>
<h2 id="2-6-字符串"><a href="#2-6-字符串" class="headerlink" title="2.6 字符串"></a>2.6 字符串</h2><pre><code>var str string // 声明一个字符串变量
str = &quot;Hello world&quot; // 字符串赋值
ch := str[0] // 取字符串的第一个字符
fmt.Printf(&quot;The length of \&quot;%s\&quot; is %d \n&quot;, str, len(str)) 
fmt.Printf(&quot;The first character of \&quot;%s\&quot; is %c.\n&quot;, str, ch) </code></pre><h2 id="2-7-数组"><a href="#2-7-数组" class="headerlink" title="2.7 数组"></a>2.7 数组</h2><p>常规的数组声明方法：</p>
<pre><code>[32]byte // 长度为32的数组，每个元素为一个字节
[2*N] struct { x, y int32 } // 复杂类型数组
[1000]*float64 // 指针数组
[3][5]int // 二维数组
[2][2][2]float64 // 等同于[2]([2]([2]float64))</code></pre><h3 id="1-元素访问"><a href="#1-元素访问" class="headerlink" title="1. 元素访问"></a>1. 元素访问</h3><p>可以使用数组下标来访问数组中的元素。与C语言相同，数组下标从0开始，len(array)-1则表示最后一个元素的下标。下面的示例遍历整型数组并逐个打印元素内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; len(array); i++ &#123; </span><br><span class="line"> fmt.Println(&quot;Element&quot;, i, &quot;of array is&quot;, array[i]) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go语言还提供了一个关键字range，用于便捷地遍历容器中的元素。当然，数组也是range的支持范围。上面的遍历过程可以简化为如下的写法：</p>
<pre><code>for i, v := range array { 
 fmt.Println(&quot;Array element[&quot;, i, &quot;]=&quot;, v) 
} </code></pre><h3 id="2-值类型"><a href="#2-值类型" class="headerlink" title="2. 值类型"></a>2. 值类型</h3><p>在Go语言中数组是一个值类型（value type）。所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。如果将数组作为函数的参数类型，则在函数调用时该参数将发生数据复制。因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是所传入<strong>数组的一个副本</strong>。</p>
<h2 id="2-8数组切片"><a href="#2-8数组切片" class="headerlink" title="2.8数组切片"></a>2.8数组切片</h2><p>数组切片就像一个指向数组的指针，实际上它拥有自己的数据结构，而不仅仅是<br>个指针。数组切片的数据结构可以抽象为以下3个变量：</p>
<ul>
<li><p>一个指向原生数组的指针； </p>
</li>
<li><p>数组切片中的元素个数； </p>
</li>
<li><p>数组切片已分配的存储空间</p>
<p>从底层实现的角度来看，数组切片实际上仍然使用数组来管理元素，因此它们之间的关系让C++程序员们很容易联想起STL中std::vector和数组的关系。基于数组，数组切片添加了一系列管理功能，可以随时动态扩充存放空间，并且可以被随意传递而不会导致所管理的元素被重复复制。</p>
<h3 id="1-创建数组切片"><a href="#1-创建数组切片" class="headerlink" title="1. 创建数组切片"></a>1. 创建数组切片</h3></li>
<li><p>基于数组</p>
</li>
</ul>
<pre><code>package main 
import &quot;fmt&quot; 
func main() { 
 // 先定义一个数组
 var myArray [10]int = [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} 
 // 基于数组创建一个数组切片
 var mySlice []int = myArray[:5] 

} </code></pre><ul>
<li>直接创建</li>
</ul>
<p>并非一定要事先准备一个数组才能创建数组切片。Go语言提供的内置函数make()可以用于灵活地创建数组切片。下面的例子示范了直接创建数组切片的各种方法。创建一个初始元素个数为5的数组切片，元素初始值为0：<br><em>mySlice1 := make([]int, 5)</em><br>创建一个初始元素个数为5的数组切片，元素初始值为0，并预留10个元素的存储空间：<br><em>mySlice2 := make([]int, 5, 10)</em><br>直接创建并初始化包含5个元素的数组切片：<br><em>mySlice3 := []int{1, 2, 3, 4, 5}</em></p>
<h3 id="2-元素遍历"><a href="#2-元素遍历" class="headerlink" title="2.元素遍历"></a>2.元素遍历</h3><p>传统的元素遍历方法如下: </p>
<pre><code>for i := 0; i &lt;len(mySlice); i++ { 
 fmt.Println(&quot;mySlice[&quot;, i, &quot;] =&quot;, mySlice[i]) 
} </code></pre><p>使用range关键字可以让遍历代码显得更整洁。range表达式有两个返回值，第一个是索引，<br>第二个是元素的值：</p>
<pre><code>for i, v := range mySlice { 
 fmt.Println(&quot;mySlice[&quot;, i, &quot;] =&quot;, v) 
} </code></pre><h3 id="3动态增减元素"><a href="#3动态增减元素" class="headerlink" title="3动态增减元素"></a>3动态增减元素</h3><ul>
<li>与数组相比，数组切片多了一个存储能 力（capacity）的概念，即元素个数和分配的空间可以是两个不同的值。</li>
<li>当前创建的数组切片最多可能需要存储的元素个数为50，那么如果你设置的存储能力小于50，比如20，那么在元素超过20时，底层将会发生至少一次这样的动作——重新分配一块“够大”的内存，并且需要把内容从原来的内存块复制到新分配的内存块，这会产生比较明显的开销。<br><em>*给“够大”这两个字加上引号的原因是系统并不知道多大才是够大，所以只是一个简单的猜测。比如，将原有的内存空间扩大两倍，但两倍并不一定够，所以之前提到的内存重新分配和内容复制的过程很有可能发生多次，从而明显降低系统的整体性能。</em></li>
</ul>
<p>如果需要往上例中mySlice已包含的5个元素后面继续新增元素，可以使用append()函数。<br>下面的代码可以从尾端给mySlice加上3个元素，从而生成一个新的数组切片：</p>
<pre><code>mySlice = append(mySlice, 1, 2, 3) </code></pre><p>函数append()的第二个参数其实是一个不定参数，我们可以按自己需求添加若干个元素，<br>甚至直接将一个数组切片追加到另一个数组切片的末尾：<br>mySlice2 := []int{8, 9, 10}<br>// 给mySlice后面添加另一个数组切片</p>
<pre><code>mySlice2 := []int{8, 9, 10} 
// 给mySlice后面添加另一个数组切片
mySlice = append(mySlice, mySlice2...) </code></pre><p>第二个参数mySlice2后面加了三个点，即一个省略号，如果没有这个省略号的话，会有编译错误，因为按append()的语义，从第二个参数起的所有参数都是待附加的元素。因为mySlice中的元素类型为int，所以直接传递mySlice2是行不通的。<strong>加上省略号相<br>当于把mySlice2包含的所有元素打散后传入。</strong><br>相当于：<br>mySlice = append(mySlice, 8, 9, 10) </p>
<h3 id="4-基于数组切片创建数组切片"><a href="#4-基于数组切片创建数组切片" class="headerlink" title="4. 基于数组切片创建数组切片"></a>4. 基于数组切片创建数组切片</h3><pre><code>oldSlice := []int{1, 2, 3, 4, 5} 
newSlice := oldSlice[:3] // 基于oldSlice的前3个元素构建新数组切片</code></pre><p>   选择的oldSlicef元素范围甚至可以超过所包含的元素个数，比如newSlice可以基于oldSlice的前6个元素创建，虽然oldSlice只包含5个元素。只要这个选择的范围不超过oldSlice存储能力（即cap()返回的值），那么这个创建程序就是合法的。newSlice中超出oldSlice元素的部分都会填上0。</p>
<h3 id="5-内容复制"><a href="#5-内容复制" class="headerlink" title="5.内容复制"></a>5.内容复制</h3><pre><code>slice1 := []int{1, 2, 3, 4, 5} 
slice2 := []int{5, 4, 3} 
copy(slice2, slice1) // 只会复制slice1的前3个元素到slice2中
copy(slice1, slice2) // 只会复制slice2的3个元素到slice1的前3个位置</code></pre><h2 id="2-9-MAP"><a href="#2-9-MAP" class="headerlink" title="2.9  MAP"></a>2.9  MAP</h2><pre><code>package main
import &quot;fmt&quot;

type Person struct{
    id string
    name string
    age int 
}

    func main(){
        var personMap map[string] Person
        personMap=make(map[string] Person)
        //插入数据
        personMap[&quot;01&quot;]=Person{&quot;01&quot;,&quot;yujuan&quot;,18}
        personMap[&quot;02&quot;]=Person{&quot;02&quot;,&quot;hong&quot;,22}
        personMap[&quot;03&quot;]=Person{&quot;03&quot;,&quot;muxi&quot;,34}

        //查询数据
        person,ok:=personMap[&quot;02&quot;]

        if ok{ 
            fmt.Println(&quot;the person 02 is&quot;,person.name,&quot; and age is &quot;,person.age)
        }else{
            fmt.Println(&quot;there is no person with id 02&quot;)
        }   

        //删除数据
        delete(personMap,&quot;02&quot;)
    }</code></pre>
    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/go/" rel="tag"># go</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/09/13/GoLang/GOLang基础（二）---函数及流程控制/" rel="next" title="GOLang基础（二）---函数及流程控制.md">
                  <i class="fa fa-chevron-left"></i> GOLang基础（二）---函数及流程控制.md
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/09/13/GoLang/Go千万级消息推送/" rel="prev" title="Go千万级消息推送">
                  Go千万级消息推送 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1变量"><span class="nav-number">1.</span> <span class="nav-text">1变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1变量声明"><span class="nav-number">1.1.</span> <span class="nav-text">1.1变量声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2变量初始化"><span class="nav-number">1.2.</span> <span class="nav-text">1.2变量初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3变量赋值"><span class="nav-number">1.3.</span> <span class="nav-text">1.3变量赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4匿名变量"><span class="nav-number">1.4.</span> <span class="nav-text">1.4匿名变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5常量"><span class="nav-number">1.5.</span> <span class="nav-text">1.5常量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-3预定义常量"><span class="nav-number">2.</span> <span class="nav-text">1.3预定义常量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4枚举"><span class="nav-number">2.1.</span> <span class="nav-text">1.4枚举</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2类型"><span class="nav-number">3.</span> <span class="nav-text">2类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1布尔类型"><span class="nav-number">3.1.</span> <span class="nav-text">2.1布尔类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2整型"><span class="nav-number">3.2.</span> <span class="nav-text">2.2整型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3位运算"><span class="nav-number">3.3.</span> <span class="nav-text">2.3位运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4浮点类型"><span class="nav-number">3.4.</span> <span class="nav-text">2.4浮点类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5复数"><span class="nav-number">3.5.</span> <span class="nav-text">2.5复数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-复数表示"><span class="nav-number">3.5.0.1.</span> <span class="nav-text">1. 复数表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-实部和虚部"><span class="nav-number">3.5.0.2.</span> <span class="nav-text">2.实部和虚部</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-字符串"><span class="nav-number">3.6.</span> <span class="nav-text">2.6 字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-数组"><span class="nav-number">3.7.</span> <span class="nav-text">2.7 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-元素访问"><span class="nav-number">3.7.1.</span> <span class="nav-text">1. 元素访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-值类型"><span class="nav-number">3.7.2.</span> <span class="nav-text">2. 值类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-8数组切片"><span class="nav-number">3.8.</span> <span class="nav-text">2.8数组切片</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-创建数组切片"><span class="nav-number">3.8.1.</span> <span class="nav-text">1. 创建数组切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-元素遍历"><span class="nav-number">3.8.2.</span> <span class="nav-text">2.元素遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3动态增减元素"><span class="nav-number">3.8.3.</span> <span class="nav-text">3动态增减元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-基于数组切片创建数组切片"><span class="nav-number">3.8.4.</span> <span class="nav-text">4. 基于数组切片创建数组切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-内容复制"><span class="nav-number">3.8.5.</span> <span class="nav-text">5.内容复制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-9-MAP"><span class="nav-number">3.9.</span> <span class="nav-text">2.9  MAP</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">阿娟</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">阿娟</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>
<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  

</body>
</html>
